namespace Percupuff
{
    processor Envelope {
        input event float releaseIn;
        input event void triggerIn;

        output stream float gainOut;

        float currentLevel = 0.0f;
        float releaseSeconds = 0.5f;
        float minimumLevel = 0.001f;
        float targetLevel = 1.0f;
        float attackSeconds = 0.01f;
        bool triggerNote = false;

        event releaseIn(float r) {
            releaseSeconds = max(0.001f, r);
        }

        event triggerIn() {
            triggerNote = true;
        }

        float calculateMultiplier(float startLevel, float endLevel, int32 lengthInSamples) {
            //return 1.0f + (log(endLevel) - log(startLevel)) / float(lengthInSamples);
            let exponentFactor = 6.0f;
            float t = 1.0f / float(lengthInSamples);  // Incremental step over the envelope
            return startLevel + (endLevel - startLevel) * ((1.0f - exp(-exponentFactor * t)) / (1.0f - exp(-exponentFactor)));
        }

        void main() {
            loop {
                while (!triggerNote)
                    advance();

                triggerNote = false;

                int32 attackSamples = int32(attackSeconds * float(processor.frequency));
                currentLevel = max(minimumLevel, currentLevel);
                float stepSize = (targetLevel - currentLevel) / float(attackSamples);
                
                while (attackSamples > 0) {
                    currentLevel += stepSize;
                    gainOut <- currentLevel;
                    advance();
                    attackSamples -= 1;
                }

                int32 releaseSamples = int32(releaseSeconds * float(processor.frequency));
                float multiplier = calculateMultiplier(currentLevel, minimumLevel, releaseSamples);

                while (releaseSamples > 0 && !triggerNote) {
                    gainOut <- currentLevel;
                    currentLevel *= multiplier;
                    advance();
                    releaseSamples -= 1;
                }

                gainOut <- currentLevel;
                advance();
            }
        }
    }
}
