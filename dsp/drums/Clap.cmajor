// https://www.muzines.co.uk/articles/the-poor-mans-guide-to-clap-sounds/7876

namespace Percupuff
{
    namespace Drums
    {
        // Generates a clap sound. It uses white noise, shapes it with filters
        // and then "retriggers" the envelope to simulate the overlapping hits
        // of multiple hands clapping.
        processor Clap {
            input event (std::notes::NoteOn) eventIn;
            input stream float noiseIn;
            output stream float<2> out;
            input event Params paramsIn;
            
            float triggerVelocity = 0.0f;
            float feedback = 0.0f;
            int midiNotePitch = 0;
            float outputLevel = 0.5f;
            float panning = 0.0f;
            const float highPassCutoff = 700.0f;

            event paramsIn(Params p) {
                midiNotePitch = int(p.clap1Midi);
                outputLevel = p.clap1Level * 0.01f;
                panning = p.clap1Panning;
            }

            event eventIn(std::notes::NoteOn n) {
                if (int (n.pitch) == midiNotePitch) {
                    triggerVelocity = sqrt(n.velocity);
                    envelope.attackIn <- 0.001f;

                    // This should be a param.
                    envelope.releaseIn <- .13f;
                }
            }

            node envelope = Envelope;
            node highpass = std::filters::butterworth::Processor(std::filters::butterworth::Mode::highPass, highPassCutoff);
            LpfResonant lowpass = (0.0f, 0.0f);

            void main()
            {
                let invSampleRate = 1.0f / float(processor.frequency);
                let retriggerCounterStart = int(float(processor.frequency) * 0.015);
                let repeatFloatDecay = 0.85f;
                let numberOfRetriggers = 7;
                loop
                {
                    while (triggerVelocity == 0) {
                        advance();
                    }

                    let vel = triggerVelocity;
                    triggerVelocity = 0.0f;
                    envelope.triggerIn <- void;
                    envelope.advance();
                    float gain = envelope.gainOut;

                    // Configures how many retriggers, and how spaced out they
                    // are in individual samples. During the loop we will simply
                    // subtract one from retriggerCounter until it hits 0.
                    int retriggers = numberOfRetriggers;
                    int retriggerCounter = retriggerCounterStart;

                    // The gain or volume of each retrigger will be lower
                    // according to repeatFloatDecay.
                    float repeatGain = 1.0f;

                    while (gain > 0.0f && triggerVelocity == 0.0f) {
                        // Removes frequencies below highPassCutoff.
                        highpass.in <- noiseIn;

                        // Each retrigger will be slighter "darker".
                        let lowPassCutoff = 2800.0f + (numberOfRetriggers - retriggers) * 100.0f;
                        let sample = lowpass.getSample(highpass.out, lowPassCutoff, 0.9f, invSampleRate);

                        let outSample = ((sample + (noiseIn * 0.15f)) * gain * (0.3f + vel * 0.3f) * repeatGain) * outputLevel;

                        float pan = panning * 0.01f;
                        float leftGain  = 0.5f * (1.0f - pan);
                        float rightGain = 0.5f * (1.0f + pan);
                        out <- (outSample * leftGain, outSample * rightGain);

                        // Compute retriggers. When it's time to retrigger, we
                        // literally just call triggerIn on the envelope again.
                        if (retriggers > 0 && retriggerCounter == 0) {
                            envelope.triggerIn <- void;
                            retriggers -= 1;
                            retriggerCounter = retriggerCounterStart;
                            if (retriggers < 6) {
                                repeatGain = repeatGain * repeatFloatDecay;
                            }
                        }

                        retriggerCounter--;
                        
                        gain = envelope.gainOut;
                        envelope.advance();
                        highpass.advance();
                        advance();
                    }
                }
            }
        }
    }
}