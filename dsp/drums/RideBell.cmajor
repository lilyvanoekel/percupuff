namespace Percupuff
{
    namespace Drums
    {
        processor RideBell {
            input event (std::notes::NoteOn) eventIn;
            output stream float<2> out;
            input event Params paramsIn;

            float triggerVelocity = 0.0f;
            int midiNotePitch = 0;
            float outputLevel = 0.5f;
            float panning = 0.0f;

            // Velocity sensitivity is not implemented yet
            float velocitySensitivity = 1.0f;

            event paramsIn(Params p) {
                midiNotePitch = int(p.rideBellMidi);
                outputLevel = p.rideBellLevel * 0.01f;
                panning = p.rideBellPanning;
                velocitySensitivity = p.rideBellVelocity;
            }

            event eventIn(std::notes::NoteOn n) {
                if (int (n.pitch) == midiNotePitch) {
                    triggerVelocity = sqrt(n.velocity);
                }
            }

            node envelope = Envelope;
            node osc1 = Oscillator(OscillatorShape::sine);
            node osc2 = Oscillator(OscillatorShape::sine);
            node osc3 = Oscillator(OscillatorShape::sine);
            node osc4 = Oscillator(OscillatorShape::sine);

            const float highPassCutoff = 800.0f;
            node highpass = std::filters::butterworth::Processor(
                std::filters::butterworth::Mode::highPass, highPassCutoff
            );

            const float lowPassCutoff = 12000.0f;
            node lowpass = std::filters::butterworth::Processor(
                std::filters::butterworth::Mode::lowPass, lowPassCutoff
            );

            void main()
            {
                envelope.attackIn <- 0.001f;
                envelope.releaseIn <- 1.0f;

                loop
                {
                    while (triggerVelocity == 0) {
                        advance();
                    }

                    let vel = triggerVelocity;
                    triggerVelocity = 0.0f;

                    envelope.triggerIn <- void;
                    envelope.releaseIn <- 0.8f + vel * 0.4f;
                    envelope.advance();

                    // Base frequency and inharmonic ratios
                    float baseFreq = 880.0f;
                    float ratio1 = 1.0f;
                    float ratio2 = 1.52f;
                    float ratio3 = 2.03f;
                    float ratio4 = 2.87f;

                    osc1.frequencyIn <- baseFreq * ratio1;
                    osc2.frequencyIn <- baseFreq * ratio2;
                    osc3.frequencyIn <- baseFreq * ratio3;
                    osc4.frequencyIn <- baseFreq * ratio4;

                    // Slight detuning
                    osc2.frequencyModIn <- 0.3f;
                    osc3.frequencyModIn <- -0.2f;

                    float gain = envelope.gainOut;

                    while (gain > 0.001f && triggerVelocity == 0.0f)
                    {
                        // Mix oscillators into a temporary variable
                        let sample = (osc1.out * 0.4f +
                                      osc2.out * 0.3f +
                                      osc3.out * 0.2f +
                                      osc4.out * 0.1f) * gain * vel * outputLevel;

                        // Apply highpass and lowpass filtering
                        highpass.in <- sample;
                        lowpass.in <- highpass.out;

                        let filtered = lowpass.out;

                        float pan = panning * 0.01f;
                        float leftGain  = 0.5f * (1.0f - pan);
                        float rightGain = 0.5f * (1.0f + pan);
                        out <- (filtered * leftGain, filtered * rightGain);

                        osc1.advance();
                        osc2.advance();
                        osc3.advance();
                        osc4.advance();
                        highpass.advance();
                        lowpass.advance();
                        envelope.advance();
                        advance();

                        gain = envelope.gainOut;
                    }
                }
            }

        }
    }
}