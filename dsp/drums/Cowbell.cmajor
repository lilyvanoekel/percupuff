// https://www.soundonsound.com/techniques/synthesizing-cowbells-claves

namespace Percupuff
{
    namespace Drums
    {
        // A cowbell sound is emulated by two oscillators tuned to specific
        // frequencies outputting a triangle wave.
        processor Cowbell {
            input event (std::notes::NoteOn) eventIn;
            output stream float<2> out;
            input event Params paramsIn;
            
            float triggerVelocity = 0.0f;
            int midiNotePitch = 0;
            float outputLevel = 0.5f;
            float panning = 0.0f;
            const float highPassCutoff = 700.0f;

            event paramsIn(Params p) {
                midiNotePitch = int(p.cowbellMidi);
                outputLevel = p.cowbellLevel * 0.01f;
                panning = p.cowbellPanning;
            }

            event eventIn(std::notes::NoteOn n) {
                if (int (n.pitch) == midiNotePitch) {
                    triggerVelocity = sqrt(n.velocity);
                }
            }

            node envelope = Envelope;
            node osc1 = Oscillator(OscillatorShape::triangle);
            node osc2 = Oscillator(OscillatorShape::triangle);
            node highpass = std::filters::butterworth::Processor(std::filters::butterworth::Mode::highPass, highPassCutoff);
            
            void main()
            {
                envelope.attackIn <- .001f;

                // The magic cowbell frequencies from the article.
                osc1.frequencyIn <- 587.0f;
                osc2.frequencyIn <- 845.0f;

                // Most other percussion processors only rely on an amplitude
                // envelope to define how the volume rises and falls over time.
                // Here we also add a short ramp-down right after the note is 
                // triggered. This extra fade smooths out the initial transient
                // so the cowbell doesnâ€™t sound too clicky or harsh at the attack.
                let rampDownSamples = int(processor.frequency * 0.02);
                let rampdownAmount = 0.7f / float(rampDownSamples);
                
                loop
                {
                    while (triggerVelocity == 0) {
                        advance();
                    }

                    let vel = triggerVelocity;
                    triggerVelocity = 0.0f;

                    // Velocity effects the release of the envelope, or the
                    // "decay" of the cowbell sound. It affects how long you can
                    // hear the cowbell "fade out" and sounds kind of like an
                    // echo or reverb. The base value of this should probably be
                    // a parameter.
                    envelope.releaseIn <- .2f + vel * 0.4f;
                    envelope.triggerIn <- void;
                    envelope.advance();
                    float gain = envelope.gainOut;

                    // Variables to support the volume ramp down.
                    int r = rampDownSamples;
                    float gainReduce = 0.0f;
                    
                    while (gain > 0.0f && triggerVelocity == 0.0f) {
                        // The sound of the two oscillators is simply summed. 
                        // The cowbell effect comes from the interaction of
                        // their frequencies.
                        //
                        // Currently they are mixed equally, but it could be a
                        // parameter to affect how much of one or the other
                        // oscillator to mix in.
                        //
                        // The sine function here is a form of distortion
                        // (waveshaping) and the 1.0f is a sort of gain or
                        // "overdrive" factor for it. Multiplying by 1.0f is
                        // silly, but this could be a user controlled parameter
                        // to make the cowbell more aggressive.
                        let sample = sin((osc1.out + osc2.out) * 1.0f);
                        highpass.in <- sample;
                        
                        let outSample = (highpass.out * (gain * (1.0f - gainReduce)) * (0.5f + vel * 0.5f)) * outputLevel;

                        float pan = panning * 0.01f;
                        float leftGain  = 0.5f * (1.0f - pan);
                        float rightGain = 0.5f * (1.0f + pan);
                        out <- (outSample * leftGain, outSample * rightGain);

                        // Calculate the volume ramp down for the next sample.
                        if (r > 0) {
                            gainReduce += rampdownAmount;
                        }

                        osc1.advance();
                        osc2.advance();
                        highpass.advance();
                        
                        gain = envelope.gainOut;
                        envelope.advance();
                        advance();

                        r--;
                    }
                }
            }
        }
    }
}