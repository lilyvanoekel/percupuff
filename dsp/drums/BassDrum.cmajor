namespace Percupuff
{
    namespace Drums
    {
        float fastTanh(float x) {
            if (x > 3.0f) return 1.0f;
            if (x < -3.0f) return -1.0f;
            float x2 = x * x;
            return x * (27.0f + x2) / (27.0f + 9.0f * x2);
        }

        struct Lpf {
            float n3, n4;

            float getSample(float in, float cutoff, float resonance, float freqModIn, float sampleRate) {
                let cut_lp = clamp(cutoff * (1.0f + freqModIn) * 2.0f / sampleRate, 0.0f, 0.99f);


                let fb_lp = resonance + resonance / (1.0f - cut_lp);

                this.n3 = this.n3 + cut_lp * (in - this.n3 + fastTanh(fb_lp * (this.n3 - this.n4)));
                this.n4 = this.n4 + cut_lp * (this.n3 - this.n4);

                return this.n4;
            }
        }



        processor BassDrum {
            input event (std::notes::NoteOn) eventIn;
            output stream float out;
            
            float triggerVelocity = 0.0f;

            event eventIn(std::notes::NoteOn n) {
                if (int (n.pitch) == BASS_DRUM_MIDI_PITCH) {
                    triggerVelocity = n.velocity;
                }
            }

            node osc = OscillatorBank;
            node envelope = Envelope;
            node envelope2 = Envelope;
            node carrier = Oscillator;
            node modulator = Oscillator;
            node highPass = std::filters::butterworth::Processor(std::filters::butterworth::Mode::highPass, 250.0f);
            
            Lpf lpf = (0.0f, 0.0f);

            void main()
            {
                // @todo: make param or constant
                let baseFrequency = 49.0f;

                osc.frequencyIn <- float<8>(
                    50,
                    93,
                    136,
                    182,
                    225,
                    273,
                    0,
                    0
                );

                osc.levelIn <- float<8>(
                    1.5f,
                    0.5f,
                    0.4f,
                    0.3f,
                    0.2f,
                    0.2f,
                    0,
                    0
                );

                envelope.releaseIn <- .3f;
                envelope2.releaseIn <- .05f;

                carrier.frequencyIn <- 500.0f;
                modulator.frequencyIn <- 166.0f;

                loop
                {
                    while (triggerVelocity == 0) {
                        advance();
                    }

                    triggerVelocity = 0.0f;

                    envelope.triggerIn <- void;
                    envelope2.triggerIn <- void;

                    envelope.advance();
                    envelope2.advance();
                    float gain = envelope.gainOut;

                    while (gain > 0.0f && triggerVelocity == 0.0f) {
                        modulator.frequencyModIn <- gain * 0.01f;
                        let mod = modulator.out;
                        modulator.advance();

                        carrier.frequencyModIn <- mod;
                        let car = carrier.out;
                        carrier.advance();

                        highPass.in <- car;
                        float lpSample = lpf.getSample(highPass.out, 1000.0f + 2500.0f * envelope2.gainOut, 0.0f, 0.0f, float(processor.frequency));

                        osc.frequencyModIn <- gain * 0.01f;
                        osc.advance();
                        out <- (sin(osc.out * 1.2f) + lpSample * 0.17f) * gain;
                        // out <- sin(osc.out * 2.0f) * gain;
                        
                        gain = envelope.gainOut;
                        envelope.advance();
                        envelope2.advance();
                        highPass.advance();

                        advance();
                    }
                }
            }
        }
    }
}