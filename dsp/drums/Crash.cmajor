// https://www.soundonsound.com/techniques/practical-cymbal-synthesis

// From the article this module attempts to implement "Synthesizing The Cymbal
// Sound: Part 2", but arguably not very well at this point. This one needs a 
// but more attention. We might need to scrap the 6 vectorized oscillators and
// implement 6 separate ones that can modulate each other properly.
//
// Worth noting that while not convincing crash cymbals, the generated sounds
// of the current approach might still be valid as other kinds of percussion.

namespace Percupuff
{
    namespace Drums
    {
        // Vectorized PolyBlep function. See the README for more information on
        // these concepts.
        T polyblepVectorized<T> (T phase, T increment) {
            T result;

            T p1 = phase / increment;
            T value1 = (p1 + p1) - (p1 * p1) - 1.0f;

            T p2 = (phase - 1.0f) / increment;
            T value2 = (p2 + p2) + (p2 * p2) + 1.0f;

            result = select(phase < increment, value1, T(0.0f));
            result = select(phase > (1.0f - increment), value2, result);
            return result;
        }
        
        // This is a helper processor for the Crash processor. It creates six
        // oscillators that are tuned to inharmonic frequencies and perform
        // frequency modulation.
        processor MetallicSoundGenerator {
            output stream float out;

            // This allows the frequencies to all be raised or lowered by the
            // same amount.
            input event float frequencyMultiplierIn;

            float<6> phase;
            float<6> increment;
            float<6> frequency = (
                1047.0f,
                1481.0f,
                1109.0f,
                2490.0f,
                1397.0f,
                2690.0f
            );
            float frequencyMultiplier = 0.6f;
            float<6> fs = (float(processor.frequency));
            float<6> previousSample = (0.0f);
            
            event frequencyMultiplierIn(float f) {
                frequencyMultiplier = f;
            }

            void main() {
                let referenceSampleRate = 44100.0f;
                let fmAdjust = (referenceSampleRate / float(processor.frequency));

                loop
                {
                    float pmModFactor = 0.05f;
                    float fmModFactor = 2.0f;
                    float<6> frequencyModIn = (
                        0.0f,
                        previousSample[0] * pmModFactor,
                        0.0f,
                        previousSample[2] * pmModFactor,
                        0.0f,
                        previousSample[4] * pmModFactor
                    );
                    float<6> moddedFrequency = (
                        frequency[0],
                        frequency[1] + previousSample[0] * frequency[1] * fmModFactor,
                        frequency[2],
                        frequency[3] + previousSample[2] * frequency[3] * fmModFactor,
                        frequency[4],
                        frequency[5] + previousSample[3] * frequency[5] * fmModFactor
                    );
                    moddedFrequency *= frequencyMultiplier;
                    increment = fmod (moddedFrequency / fs, float<6>(1.0f));
                    phase = phase + increment + frequencyModIn * fmAdjust;
                    phase = fmod(phase, float<6>(1.0f));
                    phase = select(phase < 0.0f, phase + 1.0f, phase);

                    float<6> halfPhase = fmod(phase + 0.5f, float<6>(1.0f));
                    float<6> squareWave = select(phase < 0.5f, float<6>(-1.0f), float<6>(1.0f));
                    float<6> polyblep1 = polyblepVectorized(phase, increment);
                    float<6> polyblep2 = polyblepVectorized(halfPhase, increment);
                    
                    let sample = squareWave - polyblep1 + polyblep2;
                    previousSample = sample;
                    out <- sample[1] + sample[3] + sample[5];

                    advance();
                }
            }
        }
        
        processor Crash {
            input event (std::notes::NoteOn) eventIn;
            input stream float noiseIn;
            output stream float<2> out;
            input event Params paramsIn;

            float triggerVelocity = 0.0f;
            int crash1Pitch = 0;
            int crash2Pitch = 0;
            int chinesePitch = 0;
            float outputLevel = 0.5f;
            float panning = 0.0f;

            event paramsIn(Params p) {
                crash1Pitch = int(p.crash1Midi);
                crash2Pitch = int(p.crash2Midi);
                chinesePitch = int(p.crash3Midi);
                outputLevel = p.crashLevel * 0.01f;
                panning = p.crashPanning;
            }

            event eventIn(std::notes::NoteOn n) {
                if (int (n.pitch) == crash1Pitch) {
                    triggerVelocity = sqrt(n.velocity);
                    highpass.frequency <- 4500.0f;
                    generator.frequencyMultiplierIn <- 0.75f;
                }
                if (int (n.pitch) == crash2Pitch) {
                    triggerVelocity = sqrt(n.velocity);
                    highpass.frequency <- 4000.0f;
                    generator.frequencyMultiplierIn <- 0.6f;
                }
                if (int (n.pitch) == chinesePitch) {
                    triggerVelocity = sqrt(n.velocity);
                    highpass.frequency <- 4000.0f;
                    generator.frequencyMultiplierIn <- 0.4f;
                }
            }

            node envelope = Envelope;
            node envelope2 = Envelope;
            node highpass = std::filters::butterworth::Processor(
                std::filters::butterworth::Mode::highPass,
                1000.0f
            );
            node generator = MetallicSoundGenerator;

            void main()
            {
                envelope.releaseIn <- 1.0f;
                envelope.attackIn <- .02f;
                envelope2.attackIn <- 0.001f;
                envelope2.releaseIn <- 0.4f;
                loop
                {
                    while (triggerVelocity == 0) {
                        advance();
                    }

                    let vel = triggerVelocity;
                    triggerVelocity = 0.0f;
                    envelope.triggerIn <- void;
                    envelope2.triggerIn <- void;
                    envelope.advance();
                    float gain = envelope.gainOut;

                    while (gain > 0.0f && triggerVelocity == 0.0f) {
                        let sample = generator.out;
                        highpass.in <- sample * 0.13f;

                        let outSample = (highpass.out * gain + sample * envelope2.gainOut * 0.05f) * outputLevel;

                        float pan = panning * 0.01f;
                        float leftGain  = 0.5f * (1.0f - pan);
                        float rightGain = 0.5f * (1.0f + pan);
                        out <- (outSample * leftGain, outSample * rightGain);

                        highpass.advance();
                        generator.advance();
                        gain = envelope.gainOut;
                        envelope.advance();
                        envelope2.advance();
                        advance();
                    }
                }
            }
        }
    }
}