// https://www.soundonsound.com/techniques/synthesizing-realistic-cymbals
// https://www.soundonsound.com/techniques/practical-cymbal-synthesis

namespace Percupuff
{
    namespace Drums
    {
        processor Hihat {
            input event (std::notes::NoteOn) eventIn;
            input event Params paramsIn;
            input stream float noiseIn;
            output stream float out;
            
            float triggerVelocity = 0.0f;
            float feedback = 0.0f;
            float noiseLevel = 0.3f;
            float outputLevel = 0.5f;

            int hihatClosedPitch = 0;
            int pedalHihatPitch = 0;
            int hihatOpenPitch = 0;

            event paramsIn(Params p) {
                hihatClosedPitch = int(p.hihat1Midi);
                pedalHihatPitch = int(p.hihat2Midi);
                hihatOpenPitch = int(p.hihat3Midi);
                outputLevel = p.hihatLevel * 0.01f;
            }

            event eventIn(std::notes::NoteOn n) {
                if (int (n.pitch) == hihatClosedPitch) {
                    triggerVelocity = n.velocity;
                    envelope.releaseIn <- .3f;
                    noiseLevel = 0.8f;
                    highpass.frequency <- 9000.0f;
                }
                if (int (n.pitch) == pedalHihatPitch) {
                    triggerVelocity = n.velocity;
                    envelope.releaseIn <- .2f;
                    noiseLevel = 0.2f;
                    highpass.frequency <- 7000.0f;
                }
                if (int (n.pitch) == hihatOpenPitch) {
                    triggerVelocity = n.velocity;
                    envelope.releaseIn <- .8f;
                    noiseLevel = 0.5f;
                    highpass.frequency <- 9000.0f;
                }
            }

            node envelope = Envelope;
            node osc1 = Oscillator(OscillatorShape::sine);
            node osc2 = Oscillator(OscillatorShape::sine);
            node highpass = std::filters::butterworth::Processor(std::filters::butterworth::Mode::highPass, 11000.0f);

            let invSampleRate = 1.0f / float(processor.frequency);

            void main()
            {
                
                osc1.frequencyIn <- 1047.0f;
                osc2.frequencyIn <- 2490.0f;

                loop
                {
                    while (triggerVelocity == 0) {
                        advance();
                    }

                    let vel = triggerVelocity;
                    triggerVelocity = 0.0f;
                    envelope.triggerIn <- void;
                    envelope.advance();
                    float gain = envelope.gainOut;

                    while (gain > 0.0f && triggerVelocity == 0.0f) {
                        osc1.frequencyModIn <- feedback * 0.0f;
                        osc2.frequencyModIn <- osc1.out * 1.8f;
                        feedback = osc2.out;
                        highpass.in <- osc2.out + noiseIn * noiseLevel;

                        let sample = highpass.out;
                        out <- sample * gain * (0.15f + vel * 0.15f) * outputLevel;

                        osc1.advance();
                        osc2.advance();
                        highpass.advance();
                        
                        gain = envelope.gainOut;
                        envelope.advance();
                        advance();
                    }
                }
            }
        }
    }
}