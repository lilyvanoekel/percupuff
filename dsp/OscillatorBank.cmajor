namespace Percupuff
{
    // Please read the comments on Oscillator.cmajor first, as they apply here
    // too. This processor controls 8 independent oscillators. This attempts to
    // use "vectorization", which is a technique to run multiple calculations
    // in the same instruction on the CPU. Whether it achieves this goal
    // depends on where the code runs and how it is compiled.
    //
    // This is used for additive synthesis. This means we construct a more
    // complex sound by combining various tones.
    processor OscillatorBank(OscillatorShape shape = OscillatorShape::sine) {
        input event float<8> frequencyIn;
        input event float<8> levelIn;
        input stream float frequencyModIn;
        output stream float out;

        const int tableSize = 4096;
        const float phaseToIndexMultiplier = float(tableSize) / PI_PI;

        float[tableSize] waveTable;

        float<8> phase = 0.0f;
        float<8> phaseIncrement = 0.0f;
        float<8> level = (1.0f);

        event frequencyIn(float<8> frequency) {
            phaseIncrement = (PI_PI * frequency) / float<8>(processor.frequency);
        }

        event levelIn(float<8> l) {
            level = l / sum(l);
        }

        void init() {
            if (shape == OscillatorShape::triangle) {
                for (wrap<tableSize> i) {
                    float t = float(i) / float(tableSize);
                    if (t < 0.5f) {
                        waveTable[i] = 4.0f * t - 1.0f;
                    } else {
                        waveTable[i] = 3.0f - 4.0f * t;
                    }
                }
            } else {
                for (wrap<tableSize> i) {
                    waveTable[i] = sin(2.0f * PI * float(i) / float(tableSize));
                }
            }
        }

        void main() {
            let referenceSampleRate = 44100.0f;
            let fmAdjust = (referenceSampleRate / float(processor.frequency));
            loop {
                phase += phaseIncrement + frequencyModIn * fmAdjust;
                phase = fmod(phase, float<8>(PI_PI)); 
                phase = select(phase < 0.0f, phase + PI_PI, phase);

                let indexFloat = phase * phaseToIndexMultiplier;
                let index = int<8>(indexFloat);
                let nextIndex = index + 1;
                let frac = indexFloat - index;

                float<8> currentSamples = (
                    waveTable[wrap<tableSize>(index[0])],
                    waveTable[wrap<tableSize>(index[1])],
                    waveTable[wrap<tableSize>(index[2])],
                    waveTable[wrap<tableSize>(index[3])],
                    waveTable[wrap<tableSize>(index[4])],
                    waveTable[wrap<tableSize>(index[5])],
                    waveTable[wrap<tableSize>(index[6])],
                    waveTable[wrap<tableSize>(index[7])]
                );

                float<8> nextSamples = (
                    waveTable[wrap<tableSize>(nextIndex[0])],
                    waveTable[wrap<tableSize>(nextIndex[1])],
                    waveTable[wrap<tableSize>(nextIndex[2])],
                    waveTable[wrap<tableSize>(nextIndex[3])],
                    waveTable[wrap<tableSize>(nextIndex[4])],
                    waveTable[wrap<tableSize>(nextIndex[5])],
                    waveTable[wrap<tableSize>(nextIndex[6])],
                    waveTable[wrap<tableSize>(nextIndex[7])]
                );
                
                float<8> sample = currentSamples * (1.0f - frac) + nextSamples * frac;
                sample *= level;
                out <- sum(sample);
                advance();
            }
        }
    }

    processor PolyblepOscillatorBank {
        input event float<8> frequencyIn;
        input event float<8> levelIn;
        input stream float<8> frequencyModIn;
        output stream float out;

        float<8> phase;
        float<8> increment;
        float<8> level = float<8>(1.0f) / sum(float<8>(1.0f));

        event frequencyIn (float<8> f) {
            increment = fmod (f / float(processor.frequency), float<8>(1.0f));
        }

        event levelIn(float<8> l) {
            level = l / sum(l);
        }

        float<8> polyblep (float<8> phase, float<8> increment) {
            float<8> result;

            bool<8> condition1 = phase < increment;
            float<8> p1 = phase / increment;
            float<8> value1 = (p1 + p1) - (p1 * p1) - 1.0f;

            bool<8> condition2 = phase > (1.0f - increment);
            float<8> p2 = (phase - 1.0f) / increment;
            float<8> value2 = (p2 + p2) + (p2 * p2) + 1.0f;

            result = select(condition1, value1, float<8>(0.0f));
            result = select(condition2, value2, result);

            return result;
        }

        void main() {
            let referenceSampleRate = 44100.0f;
            let fmAdjust = (referenceSampleRate / float(processor.frequency));

            loop
            {
                phase = phase + increment + frequencyModIn * fmAdjust;
                phase = fmod(phase, float<8>(1.0f));
                phase = select(phase < 0.0f, phase + 1.0f, phase);

                float<8> halfPhase = fmod(phase + 0.5f, float<8>(1.0f));
                float<8> squareWave = select(phase < 0.5f, float<8>(-1.0f), float<8>(1.0f));
                float<8> polyblep1 = polyblep(phase, increment);
                float<8> polyblep2 = polyblep(halfPhase, increment);
                var sample = squareWave - polyblep1 + polyblep2;
                sample *= level;
                out <- sum(sample);

                advance();
            }
        }
    }
}
