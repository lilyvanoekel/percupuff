namespace Percupuff
{
    enum OscillatorShape
    {
        sine,
        triangle
    }

    // For our purposes and oscillator is a thing that generates a tone at a
    // certain frequency. It outputs a kind of wave that goes up and down
    // between -1 and 1, like a ~. This wave can have different shapes. The ~
    // shapes is called a sine, and sounds very "pure" (or boring). A triangle
    // looks more like /\/ and sounds a little more interesting. A square
    // wave |â€¾|_| can sound a little abbrasive.
    processor Oscillator(OscillatorShape shape = OscillatorShape::sine) {
        input event float frequencyIn;
        input stream float frequencyModIn;
        output stream float out;

        // We use a table, so while generating sound we don't have to calculate
        // every point of a sine wave.
        const int tableSize = 4096;

        // Phase describes where we are on the X axis of our wave form. To
        // generate a sound we have to continously move to the right on the
        // X axis. The phase describes where we are, and the phase increment
        // describes how much we are moving for each sample. A higher frequency
        // means more waves per second, so our phase increments becomes larger
        // and we rush through our phase quicker.
        
        // This helps us relate phase to a specific index in our table.
        const float phaseToIndexMultiplier = float(tableSize) / PI_PI;

        float[tableSize] sineTable;
        float phase = 0.0f;
        float phaseIncrement = 0.0f;

        event frequencyIn(float frequency) {
            phaseIncrement = (PI_PI * frequency) / float(processor.frequency);
        }

        void init() {
            if (shape == OscillatorShape::triangle) {
                for (wrap<tableSize> i) {
                    float t = float(i) / float(tableSize);
                    if (t < 0.5f) {
                        sineTable[i] = 4.0f * t - 1.0f;
                    } else {
                        sineTable[i] = 3.0f - 4.0f * t;
                    }
                }
            } else {
                for (wrap<tableSize> i) {
                    sineTable[i] = sin(2.0f * PI * float(i) / float(tableSize));
                }
            }
        }

        void main() {
            let referenceSampleRate = 44100.0f;
            let fmAdjust = (referenceSampleRate / float(processor.frequency));
            loop {
                phase += phaseIncrement + frequencyModIn * fmAdjust;
                
                if (phase < 0) {
                    phase += PI_PI;
                }
                if (phase >= PI_PI) {
                    phase -= PI_PI;
                }

                let indexFloat = phase * phaseToIndexMultiplier;
                let index = int(indexFloat);
                let nextIndex = index + 1;
                let frac = indexFloat - index;

                let currentSample = sineTable[wrap<tableSize>(index)];
                let nextSample = sineTable[wrap<tableSize>(nextIndex)];
                let sample = currentSample * (1.0f - frac) + nextSample * frac;
                out <- sample;
                advance();
            }
        }
    }

    processor PolyblepOscillator {
        input event float frequencyIn;
        input stream float frequencyModIn;
        output stream float out;

        float phase;
        float increment;

        event frequencyIn (float f) {
            increment = fmod (f / float(processor.frequency), 1.0f);
        }

        float polyblep (float phase, float increment) {
            if (phase < increment) {
                let p = phase / increment;
                return (p + p) - (p * p) - 1.0f;
            }

            if (phase > 1.0f - increment) {
                let p = (phase - 1.0f) / increment;
                return (p + p) + (p * p) + 1.0f;
            }

            return 0.0f;
        }

        void main() {
            let referenceSampleRate = 44100.0f;
            let fmAdjust = (referenceSampleRate / float(processor.frequency));

            loop
            {
                phase = phase + increment + frequencyModIn * fmAdjust;

                if (phase >= 1) {
                    phase -= 1;
                }

                if (phase < 0) {
                    phase += 1;
                }

                out <- (phase < 0.5f ? -1.0f : 1.0f) 
                    - polyblep (phase, increment)
                    + polyblep (fmod(phase + 0.5f, 1.0f), increment);

                advance();
            }
        }
    }
}
